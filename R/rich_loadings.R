#' Plot Loadings the long way
#' @import ggplot2
#' @export
#' @description The user need to previously launch \code{HotLoadings.names}, \code{HotLoadings.top_features}, \code{HotLoadings.mean_relative_abundances} and \code{HotLoadings.combine_abundances} in order to make this function works. Otherwise use \code{\link{HotLoadings.plot_loadings}}
#' @param top_feature A data frame containing \code{n_top} features generated by \code{\link{HotLoadings.top_features}}.
#' @param top_feature_combined A data frame containing \code{n_top} features informations and proportion between \code{Y_name} categories. Generated by \code{\link{HotLoadings.combine_abundances}}.
#' @param xlim Vector of size 2 containings plot limits for x axis of the graphic (default is -0.3, 0.3).
#' @param colors Vector of size 4 containings colors for each class of the graphic.
#'   As negative and positive values of the loading has a precise meaning, color order is important.
#'   If "Condition 1" is positively associated to specified component (positive loading) and "Condition 2" viceversa:
#'   Color1 represents the proportion of negative loading features in "Condition 1" samples;
#'   Color2 represents the proportion of negative loading features in "Condition 2" samples;
#'   Color3 represents the proportion of positive loading features in "Condition 1" samples;
#'   Color4 represents the proportion of positive loading features in "Condition 2" samples;
#' @return The function plots loadings with several informations:
#'   * \code{n_top} associated feature with component;
#'   * Relative abundances for each feature in every condition (white numbers);
#'   * The proportion between relative abundances for each feature in every condition (length of different colors inside each bar);
#' @seealso \code{\link{HotLoadings.combine_abundances}} to create combined condition abundances data frame and \code{\link{HotLoadings.plot_loadings}} for plot in a single step.


HotLoadings.plot_loadings_long <- function(top_feature,top_feature_combined,xlim = c(-0.3,0.3),colors = c("orange","red","blue","dark green")){
  minplucol = colors[1]
  minmincol = colors[2]
  plumincol = colors[4]
  pluplucol = colors[3]
  ggplot(top_feature_combined,aes(x = feature,y = proportions)) +
    geom_bar(stat = "identity",aes(fill = combined)) +
    # feature names
    geom_text(data = top_feature,aes(x = feature, y = offset, label = feature),hjust = top_feature$just) +
    # class - in +
    geom_text(data = top_feature_combined[top_feature_combined$combined == unique(top_feature_combined$combined)[2], ],aes(x = feature, y = loadings + just,label = paste(round(Relative_Abundance*100,digits = 2),"%")),hjust = "left",color = "white") +
    # class - in -
    geom_text(data = top_feature_combined[top_feature_combined$combined == unique(top_feature_combined$combined)[1], ],aes(x = feature, y = just,label = paste(round(Relative_Abundance*100,digits = 2),"%")),hjust = "right",color = "white") +
    # class + in -
    geom_text(data = top_feature_combined[top_feature_combined$combined == unique(top_feature_combined$combined)[4], ],aes(x = feature, y = loadings + just,label = paste(round(Relative_Abundance*100,digits = 2),"%")),hjust = "right",color = "white") +
    # class + in +
    geom_text(data = top_feature_combined[top_feature_combined$combined == unique(top_feature_combined$combined)[3], ],aes(x = feature, y = just,label = paste(round(Relative_Abundance*100,digits = 2),"%")),hjust = "left",color = "white") +
    coord_flip(ylim = xlim) +
    theme_minimal() +
    theme(legend.position = "bottom") +
    scale_x_discrete("", labels=NULL) +
    scale_fill_manual(values = c(minplucol,minmincol,plumincol,pluplucol),
                      breaks = levels(top_feature_combined$combined),
                      labels = c(paste(paste(strsplit(as.character(unique(top_feature_combined$combined))[2],split = " ")[[1]],collapse = " associated features in "),"samples"),
                                 paste(paste(strsplit(as.character(unique(top_feature_combined$combined))[1],split = " ")[[1]],collapse = " associated features in "),"samples"),
                                 paste(paste(strsplit(as.character(unique(top_feature_combined$combined))[4],split = " ")[[1]],collapse = " associated features in "),"samples"),
                                 paste(paste(strsplit(as.character(unique(top_feature_combined$combined))[3],split = " ")[[1]],collapse = " associated features in "),"samples"))) +
    ylab(label = "Loadings") + xlab("Features") +
    labs(fill = "Relative Abundances %:") +
    guides(fill = guide_legend(nrow=2,byrow=TRUE))
}

#' Plot Loadings the short way
#'
#' @export
#' @description The user need to be at the end of mixOmics pipeline.
#' @inheritParams HotLoadings.plot_loadings_long
#' @inheritParams HotLoadings.names
#' @inheritParams HotLoadings.top_features
#' @return The function plots loadings with several informations:
#'   * \code{n_top} associated feature with component;
#'   * Relative abundances for each feature in every condition (white numbers);
#'   * The proportion between relative abundances for each feature in every condition (length of different colors inside each bar);
#' @seealso \code{\link{HotLoadings.combine_abundances}} to create combined condition abundances data frame and \code{\link{HotLoadings.plot_loadings}} for plot in a single step.


HotLoadings.plot_loadings <- function(PSOBJ,format = c("short","last","long"),data.splsda,Y_name,component,n_top = 15,offset = 0.005, order = TRUE, xlim = c(-0.3,0.3),colors = c("orange","red","blue","dark green")){
  feature_names <- HotLoadings.names(PSOBJ = PSOBJ,format = format)
  df_top_n <- HotLoadings.top_features(data.splsda = data.splsda,feature_names = feature_names,component = component,Y_name = Y_name,n_top = n_top,offset = offset, order = order)
  mean_rel_ab <- HotLoadings.mean_relative_abundances(top_features = df_top_n,PSOBJ = PSOBJ,Y_name = Y_name)
  top_n_comb <- HotLoadings.combine_abundances(mean_relative_abundances = mean_rel_ab,Y_name = Y_name,top_features = df_top_n)
  HotLoadings.plot_loadings_long(top_feature_combined = top_n_comb,top_feature = df_top_n,xlim = xlim,colors = colors)
}

#' Plot Heatmap the long way
#'
#' @import ggplot2
#' @importFrom reshape2 melt
#' @export
#' @description The user need to previously launch \code{\link{HotLoadings.names}}, \code{\link{HotLoadings.top_features}}, in order to make this function works. Otherwise use \code{\link{HotLoadings.heat_map}}
#' @param data.splsda A sPLS-DA object from mixomics.
#' @param top_feature A data frame containing \code{n_top} features generated by \code{\link{HotLoadings.top_features}}.
#' @param PSOBJ A phyloseq object.
#' @param sample_name A character string indicating which is the variable with sample names.
#' @param Y_name A character string indicating which is the variable associated with component specified. Must be a dicothomous variable.
#' @param feature_names A character vector containing feature names.
#' @param facet_formula A formula for facetting (default is NULL).
#' @return The function plots heatmap for \code{n_top} features in rows and samples in columns.
#' @seealso \code{\link{HotLoadings.plot_loadings_long}} or \code{\link{HotLoadings.plot_loadings}} to plot loadings.


HotLoadings.heat_map_long <- function(data.splsda,top_feature,PSOBJ,sample_name,Y_name,feature_names,facet_formula = NULL){
  # Input data
  # tss_matrix <- apply((PSOBJ@otu_table@.Data)+1,2,function(x) x/sum(x))
  # clr_matrix <- t(apply(tss_matrix,2,function(x) log(x)-mean(log(x))))
  clr_matrix <- data.splsda$X
  # Top n taxa
  clr_matrix_sel <- clr_matrix[,match(rownames(top_feature),colnames(clr_matrix))]
  rownames(clr_matrix_sel) <- paste(unlist(PSOBJ@sam_data[,sample_name]),unlist(PSOBJ@sam_data[,Y_name]),sep = "-")
  other_metadata <- data.frame(PSOBJ@sam_data)
  rownames(other_metadata) <- rownames(clr_matrix_sel)
  colnames(clr_matrix_sel) <- feature_names[match(rownames(top_feature),colnames(clr_matrix))]
  clr_matrix_sel <- clr_matrix_sel[order(rownames(clr_matrix_sel)),]
  clr_matrix_sel <- clr_matrix_sel[order(gsub(x = rownames(clr_matrix_sel),pattern = "[A-Z][0-9]*[ ]*[-]",replacement = "")),]
  other_metadata <- other_metadata[rownames(clr_matrix_sel),]
  # Create a data frame from clr matrix
  clr_matrix_sel_melt <- reshape2::melt(clr_matrix_sel)
  colnames(clr_matrix_sel_melt) <- c("ticknames","feature","clr")
  repeated_other_metadata <- apply(other_metadata, 2, function(x) rep(x, nrow(top_feature)))
  clr_matrix_sel_melt <- cbind(clr_matrix_sel_melt, repeated_other_metadata)
  if(!is.null(facet_formula)){
      clr_matrix_sel_melt[,"ticknames"] <- clr_matrix_sel_melt[, sample_name]
  }
  # clr_matrix_sel_melt$clr_rescale <- rescale(clr_matrix_sel_melt$clr)

  zeropoint <- -min(clr_matrix_sel_melt$clr)/(max(clr_matrix_sel_melt$clr)-min(clr_matrix_sel_melt$clr))

  gHeat <- ggplot(clr_matrix_sel_melt,aes(x = ticknames ,y = feature, fill = clr)) +
    geom_tile(colour = "white") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45,hjust = 1,vjust = 1),
          axis.text.y = element_blank(),
          legend.position = "bottom") +
    labs(x = "Sample",y = "", fill = "Centered Log Ratio") +
    scale_fill_gradientn(colours = c("#051591","#FFFF10","#F00F47"),values = c(0,zeropoint,1))

  if(!is.null(facet_formula))
      gHeat + facet_grid(facet_formula, scales = "free_x", space = "free_x")

  gHeat
}

#' Plot Heatmap the short way
#'
#' @export
#' @description The user need to be at the end of mixOmics pipeline.
#' @inheritParams HotLoadings.names
#' @inheritParams HotLoadings.top_features
#' @param sample_name A character string indicating which is the variable with sample names.
#' @param facet_formula A formula for facetting (default is NULL).
#' @return The function plots heatmap for \code{n_top} features in rows and samples in columns.
#' @seealso \code{\link{HotLoadings.plot_loadings_long}} or \code{\link{HotLoadings.plot_loadings}} to plot loadings.

HotLoadings.heat_map <- function(PSOBJ,format = c("short","last","long"),data.splsda,Y_name,component,n_top = 15,sample_name,offset = 0.005, order = TRUE, facet_formula = NULL){
  feature_names <- HotLoadings.names(PSOBJ = PSOBJ,format = format)
  df_top_n <- HotLoadings.top_features(data.splsda = data.splsda,feature_names = feature_names,component = component,Y_name = Y_name,n_top = n_top,offset = offset, order = order)
  HotLoadings.heat_map_long(data.splsda = data.splsda,top_feature = df_top_n,PSOBJ = PSOBJ,sample_name = sample_name,Y_name = Y_name,feature_names = feature_names, facet_formula = facet_formula)
}

#' Plot Loadings and Heatmap in a sexy way
#' @importFrom cowplot plot_grid
#' @export
#' @description The user need to be at the end of mixOmics pipeline.
#' @param g_loadings a ggplot object obtained with \code{\link{HotLoadings.plot_loadings}} or \code{\link{HotLoadings.plot_loadings_long}}
#' @param g_heat_map a ggplot object obtained with \code{\link{HotLoadings.heat_map}} or \code{\link{HotLoadings.heat_map_long}}
#' @param rel_widths Numerical vector of relative columns widths. For example, in a two-column grid, rel_widths = c(2, 1) would make the first column twice as wide as the second column.
#' @return The function plots heatmap for \code{n_top} features in rows and samples in columns.
#' @seealso \code{\link{HotLoadings.plot_loadings_long}} or \code{\link{HotLoadings.plot_loadings}} to plot loadings.

HotLoadings <- function(g_loadings,g_heat_map,rel_widths = c(1, 1)){
  cowplot::plot_grid(g_loadings, g_heat_map, align = "h", ncol = 2, rel_widths = rel_widths)
}

